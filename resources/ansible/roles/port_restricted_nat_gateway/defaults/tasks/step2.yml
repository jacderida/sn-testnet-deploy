---
- name: flush nat table
  iptables:
    table: nat
    flush: yes
  when: nat_gateway_output.stdout.find(node_private_ip_eth1) == -1

- name: flush mangle table
  iptables:
    table: mangle
    flush: yes
  when: nat_gateway_output.stdout.find(node_private_ip_eth1) == -1

- name: Set backend private IP (eth1) from provided value
  set_fact:
    node_private_ip_eth1: "{{ PRIVATE_NODE_DROPLET_ETH1 | default('10.131.2.201') }}"

- name: Set gateway public IP (WAN on eth0) from provided value
  set_fact:
    gateway_public_ip: "{{ NAT_GATEWAY_WAN_IP_ETH0 | default('165.232.39.255') }}"

# If a CIDR is provided, normalize it; otherwise detect from the private node.
- name: Normalize provided VPC CIDR (fix accidental '0.0./16' → '0.0/16')
  set_fact:
    private_node_vpc_cidr_raw: "{{ PRIVATE_NODE_DROPLET_ETH1_VPC_CIDR | default('') }}"
    private_node_vpc_cidr: >-
      {{
        (PRIVATE_NODE_DROPLET_ETH1_VPC_CIDR | default(''))
        | regex_replace('/\\s*$', '')           # trim trailing slash whitespace
        | regex_replace('\\.\\s*/', '/')
      }}
  when: PRIVATE_NODE_DROPLET_ETH1_VPC_CIDR is defined and PRIVATE_NODE_DROPLET_ETH1_VPC_CIDR|length > 0

- name: Detect VPC CIDR from private node (eth1) when not provided
  shell: ip route | grep eth1 | grep kernel | awk '{print $1}' | grep -v default
  register: vpc_cidr_output
  delegate_to: "{{ node_private_ip_eth1 }}"
  become: yes
  when: private_node_vpc_cidr is not defined or private_node_vpc_cidr|length == 0

- name: Set detected VPC CIDR fact
  set_fact:
    private_node_vpc_cidr: "{{ vpc_cidr_output.stdout }}"
  when: vpc_cidr_output is defined

# Safety checks
- name: Assert we have a valid-looking CIDR
  assert:
    that:
      - private_node_vpc_cidr is defined
      - private_node_vpc_cidr | length > 0
      - private_node_vpc_cidr is match('^\\d+\\.\\d+\\.\\d+\\.\\d+/\\d+$')
    fail_msg: "PRIVATE_NODE_DROPLET_ETH1_VPC_CIDR is missing or invalid (got '{{ private_node_vpc_cidr | default('') }}')."

# Optional: show what got set (helpful while wiring up)
- name: Debug values
  debug:
    msg:
      - "node_private_ip_eth1={{ node_private_ip_eth1 }}"
      - "gateway_public_ip={{ gateway_public_ip }}"
      - "private_node_vpc_cidr={{ private_node_vpc_cidr }}"

# Vars expected (as in your earlier files):
# - gateway_public_ip: "{{ ansible_host }}"            # was NAT_GATEWAY_WAN_IP_ETH0_ETH0
# - node_private_ip_eth1: "10.131.2.201"               # was PRIVATE_NODE_DROPLET_ETH1

- name: DNAT external TCP (eth0) → internal server
  iptables:
    table: nat
    chain: PREROUTING
    in_interface: eth0
    protocol: tcp
    destination: "{{ gateway_public_ip }}"
    jump: DNAT
    to_destination: "{{ node_private_ip_eth1 }}"

- name: DNAT external UDP (eth0) → internal server
  iptables:
    table: nat
    chain: PREROUTING
    in_interface: eth0
    protocol: udp
    destination: "{{ gateway_public_ip }}"
    jump: DNAT
    to_destination: "{{ node_private_ip_eth1 }}"

- name: DNAT hairpin TCP (eth1) → internal server
  iptables:
    table: nat
    chain: PREROUTING
    in_interface: eth1
    protocol: tcp
    destination: "{{ gateway_public_ip }}"
    jump: DNAT
    to_destination: "{{ node_private_ip_eth1 }}"

- name: DNAT hairpin UDP (eth1) → internal server
  iptables:
    table: nat
    chain: PREROUTING
    in_interface: eth1
    protocol: udp
    destination: "{{ gateway_public_ip }}"
    jump: DNAT
    to_destination: "{{ node_private_ip_eth1 }}"

- name: Standard masquerade for outbound traffic
  iptables:
    table: nat
    chain: POSTROUTING
    out_interface: eth0
    jump: MASQUERADE

- name: SNAT for hairpinned traffic (rewrite source to WAN IP, not LAN IP)
  iptables:
    table: nat
    chain: POSTROUTING
    source: "{{ private_node_vpc_cidr }}"
    destination: "{{ node_private_ip_eth1 }}"
    jump: SNAT
    to_source: "{{ gateway_public_ip }}"

- name: Allow TCP forwarding to private node
  iptables:
    chain: FORWARD
    protocol: tcp
    destination: "{{ node_private_ip_eth1 }}"
    jump: ACCEPT

- name: Allow UDP forwarding to private node
  iptables:
    chain: FORWARD
    protocol: udp
    destination: "{{ node_private_ip_eth1 }}"
    jump: ACCEPT

- name: Allow established and related connections
  iptables:
    chain: FORWARD
    match: state
    ctstate: ESTABLISHED,RELATED
    jump: ACCEPT

- name: Persist iptables rules to disk
  command: service netfilter-persistent save