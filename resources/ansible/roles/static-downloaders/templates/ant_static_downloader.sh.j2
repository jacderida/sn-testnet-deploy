#!/usr/bin/env bash
# Continuous downloader script that processes a static CSV file

# Usage: ./script.sh -m MODE -c CSV_PATH [-p PEER] [-u URL] [-n ID] [-f ADDRESS]
#
#   -m, --mode: REQUIRED - must be one of: performance, delayed, random
#   -c, --csv-path: REQUIRED - path to static CSV file containing file addresses
#   -p, --peer: Optional contact peer
#   -u, --network-contacts-url: Optional network contacts URL
#   -n, --network-id: Optional network ID (also enables testnet mode)
#   -f, --file-address: Optional specific file address to download repeatedly (performance mode only)

LOG_OUTPUT_DEST="{{ log_output_dest }}"
MODE=""
CSV_PATH=""
CONTACT_PEER=""
NETWORK_CONTACTS_URL=""
NETWORK_ID=""
FILE_ADDRESS=""

usage() {
  echo "Usage: $0 -m MODE -c CSV_PATH [-p PEER] [-u URL] [-n ID] [-f ADDRESS]"
  echo "  -m, --mode                MODE: Must be one of: performance, delayed, random"
  echo "  -c, --csv-path            CSV_PATH: Path to static CSV file containing file addresses"
  echo "  -p, --peer                PEER: Optional contact peer"
  echo "  -u, --network-contacts-url URL: Optional network contacts URL"
  echo "  -n, --network-id          ID: Optional network ID (also enables testnet mode)"
  echo "  -f, --file-address        ADDRESS: Optional file address to download repeatedly (performance mode only)"
  exit 1
}

TEMP=$(getopt -o m:c:p:u:n:f: --long mode:,csv-path:,peer:,network-contacts-url:,network-id:,file-address: -n 'continuous_downloader.sh' -- "$@")

if [ $? != 0 ]; then
  echo "Failed to parse arguments" >&2
  usage
fi

# Note the quotes around "$TEMP": they are essential!
eval set -- "$TEMP"

while true; do
  case "$1" in
    -m|--mode)
      MODE="$2"
      shift 2
      ;;
    -c|--csv-path)
      CSV_PATH="$2"
      shift 2
      ;;
    -p|--peer)
      CONTACT_PEER="$2"
      shift 2
      ;;
    -u|--network-contacts-url)
      NETWORK_CONTACTS_URL="$2"
      shift 2
      ;;
    -n|--network-id)
      NETWORK_ID="$2"
      shift 2
      ;;
    -f|--file-address)
      FILE_ADDRESS="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "Internal error!"
      exit 1
      ;;
  esac
done

if [[ -z "$MODE" ]]; then
  echo "Error: Mode is required with -m or --mode parameter"
  usage
fi

if [[ -z "$CSV_PATH" ]]; then
  echo "Error: CSV file is required with -c or --csv-file parameter"
  usage
fi

if [[ "$MODE" != "performance" && "$MODE" != "delayed" && "$MODE" != "random" ]]; then
  echo "Error: Invalid mode '$MODE'. Must be one of: performance, delayed, random"
  exit 1
fi

if [[ ! -f "$CSV_PATH" ]]; then
  echo "Error: CSV file '$CSV_PATH' does not exist"
  exit 1
fi

DOWNLOAD_DIR="/mnt/ant-storage/downloaded_files"
SLEEP_INTERVAL=20
FILE_REF_INDEX=1
FILE_HASH_INDEX=2
FILE_SIZE_INDEX=3
FILE_NAME_INDEX=4

case "$MODE" in
  performance)
    DOWNLOAD_METRICS_DIR="/mnt/ant-storage/logs/download_files/performance_verifier/${USER}"
    SERVICE_TYPE="PERFORMANCE_VERIFIER"
    ;;
  delayed)
    DOWNLOAD_METRICS_DIR="/mnt/ant-storage/logs/download_files/download_verifier/${USER}"
    SERVICE_TYPE="DOWNLOAD_VERIFIER"
    ;;
  random)
    DOWNLOAD_METRICS_DIR="/mnt/ant-storage/logs/download_files/random_verifier/${USER}"
    SERVICE_TYPE="RANDOM_VERIFIER"
    ;;
  *)
    echo "Invalid mode: $MODE. Must be one of: performance, delayed, random"
    exit 1
    ;;
esac

mkdir -p "${DOWNLOAD_DIR}"
mkdir -p "${DOWNLOAD_METRICS_DIR}"

CONTACT_PEER_ARG=""
NETWORK_CONTACTS_URL_ARG=""
NETWORK_ID_ARG=""

if [[ -n "$CONTACT_PEER" ]]; then
  echo "Setting contact peer arg to $CONTACT_PEER"
  CONTACT_PEER_ARG="--peer $CONTACT_PEER"
fi
if [[ -n "$NETWORK_CONTACTS_URL" ]]; then
  echo "Setting network contacts URL arg to $NETWORK_CONTACTS_URL"
  NETWORK_CONTACTS_URL_ARG="--network-contacts-url $NETWORK_CONTACTS_URL"
fi
if [[ -n "$NETWORK_ID" ]]; then
  echo "Setting network ID arg to $NETWORK_ID"
  NETWORK_ID_ARG="--network-id $NETWORK_ID"
fi

if ! command -v ant &> /dev/null; then
  echo "Error: 'ant' not found in PATH."
  exit 1
fi

get_error_enum() {
  local exit_code=$1
  case $exit_code in
    0)
      echo "SUCCESS"
      ;;
    6)
      echo "INVALID_INPUT"
      ;;
    11)
      echo "SERIALIZATION_ERROR"
      ;;
    12)
      echo "IO_ERROR"
      ;;
    13)
      echo "NETWORK_ERROR"
      ;;
    14)
      echo "PROTOCOL_ERROR"
      ;;
    15)
      echo "SELF_ENCRYPTION_ERROR"
      ;;
    21)
      echo "EVM_WALLET_NETWORK_MISMATCH"
      ;;
    22)
      echo "EVM_WALLET_ERROR"
      ;;
    23)
      echo "PAY_COST_ERROR"
      ;;
    31)
      echo "INVALID_DATA_MAP"
      ;;
    32)
      echo "DECRYPTION_ERROR"
      ;;
    36)
      echo "UNRECOGNIZED_INPUT"
      ;;
    37)
      echo "FAILED_GET"
      ;;
    41)
      echo "PUT_COST_ERROR"
      ;;
    42)
      echo "WALLET_ERROR"
      ;;
    43)
      echo "SCRATCHPAD_BAD_OWNER"
      ;;
    44)
      echo "PAYMENT_UNEXPECTEDLY_INVALID"
      ;;
    45)
      echo "PAYEES_MISSING"
      ;;
    51)
      echo "NO_BOOTSTRAP_PEERS_FOUND"
      ;;
    52)
      echo "FAILED_TO_PARSE_CACHE_DATA"
      ;;
    53)
      echo "COULD_NOT_OBTAIN_DATA_DIR"
      ;;
    54)
      echo "FAILED_TO_OBTAIN_ADDRS_FROM_URL"
      ;;
    55)
      echo "FAILED_TO_PARSE_URL"
      ;;
    56)
      echo "JSON_ERROR"
      ;;
    57) 
      echo "HTTP_ERROR"
      ;;
    58)
      echo "LOCK_ERROR"
      ;;
    59)
      echo "CONNECTION_TIMED_OUT"
      ;;
    60)
      echo "CONNECTION_TIMED_OUT_WITH_INCOMPATIBLE_PROTOCOL"
      ;;
    61)
      echo "FAILED_TO_GET_EVM_NETWORK"
      ;;
    62)
      echo "EVM_FEES_ERROR"
      ;;
    *)
      echo "UNKNOWN_ERROR"
      ;;
  esac
}

download_file() {
  local file_ref=$1
  local expected_hash=$2
  local expected_file_size=$3
  # Multiple downloaders can be running on the same machine, so one or more
  # could select the same file address at the same time. We therefore use a GUID
  # to ensure a unique output file.
  local download_filename=$(uuidgen)
  (
    download_path="$DOWNLOAD_DIR/$download_filename"
    
    quorum_arg=""
    if [[ "$MODE" == "delayed" ]]; then
      quorum_arg="--quorum majority"
    fi

    timestamp=$(date +"%Y%m%d_%H%M%S")
    log_file_path="${LOG_OUTPUT_DEST}/${timestamp}"
    log_output_arg="--log-output-dest $log_file_path"
    
    start_time=$(date +%s%N)
    ant $CONTACT_PEER_ARG $NETWORK_CONTACTS_URL_ARG $NETWORK_ID_ARG $log_output_arg file download "$file_ref" "$download_path" $quorum_arg 2>&1
    exit_code=$?
    end_time=$(date +%s%N)
    echo "Exit code: $exit_code"
    version_stdout=$(ant --version 2>&1)
    package_version=$(echo "$version_stdout" | grep "Package version:" | awk '{print $3}')
    build_date=$(echo "$version_stdout" | grep "Git info:" | awk '{print $7}')
    echo "Package version: $package_version"
    echo "Build date: $build_date"

    elapsed=$(echo "scale=2; ($end_time - $start_time) / 1000000000" | bc)
    echo "Elapsed time: $elapsed seconds"
    error_enum=$(get_error_enum $exit_code)
    
    actual_hash="0x0"
    actual_file_size_kb=0
    if [[ $exit_code -eq 0 && -n "$expected_hash" ]]; then
      first_file=$(find "$download_path" -type f | head -n 1)
      
      if [[ -n "$first_file" ]]; then
        actual_hash=$(sha256sum "$first_file" | awk '{print $1}')
        actual_file_size_kb=$(du -k "$first_file" | cut -f1)
        
        if [[ "$actual_hash" == "$expected_hash" ]]; then
          echo "✅ Hash verification successful"
        else
          echo "❌HASH MISMATCH!"
          echo "Expected hash: $expected_hash"
          echo "Actual hash:   $actual_hash"
          exit_code=1
          error_enum=HASH_MISMATCH
        fi
      else
        echo "❌NO FILES FOUND in $download_path"
        exit_code=1
        error_enum=NO_FILES_FOUND
      fi
    fi

    rm -rf "$download_path"

    if [[ $exit_code -eq 0 ]]; then
      echo "✅ File downloaded"
      success_file="$DOWNLOAD_METRICS_DIR/metrics_success.csv"

      if [[ ! -f "$success_file" ]]; then
        echo "TIMESTAMP_START,TIMESTAMP_FINISH,DATA_ADDRESS,DURATION,RETRIES,FETCHED_RECORDS,TOTAL_RECORDS,EXIT_STATUS,SERVICE_TYPE,ANT_USER,SERVICE_NUMBER,EXPECTED_TOTAL_SIZE,ACTUAL_TOTAL_SIZE,ACTUAL_SHA256_HASH,EXPECTED_SHA256_HASH,ANT_PACKAGE_VERSION,ANT_PACKAGE_BUILD_DATE" > "$success_file"
      fi
      echo "$start_time,$end_time,$file_ref,$elapsed,0,0,0,$error_enum,$SERVICE_TYPE,$USER,1,$expected_file_size,$actual_file_size_kb,$actual_hash,$expected_hash,$package_version,$build_date" >> "$success_file"
    else
      echo "❌DOWNLOAD FAILED"
      echo "Error type: $error_enum"
      echo "Please check the logs above for more details."
      failure_file="$DOWNLOAD_METRICS_DIR/metrics_failure.csv"

      if [[ ! -f "$failure_file" ]]; then
        echo "TIMESTAMP_START,TIMESTAMP_FINISH,DATA_ADDRESS,DURATION,RETRIES,FETCHED_RECORDS,TOTAL_RECORDS,EXIT_STATUS,SERVICE_TYPE,ANT_USER,SERVICE_NUMBER,EXPECTED_TOTAL_SIZE,ACTUAL_TOTAL_SIZE,ACTUAL_SHA256_HASH,EXPECTED_SHA256_HASH,ANT_PACKAGE_VERSION,ANT_PACKAGE_BUILD_DATE" > "$failure_file"
      fi
      echo "$start_time,$end_time,$file_ref,$elapsed,0,0,0,$error_enum,$SERVICE_TYPE,$USER,1,$expected_file_size,$actual_file_size_kb,$actual_hash,$expected_hash,$package_version,$build_date" >> "$failure_file"
    fi
  )
}

current_line_index=2
TOTAL_LINES=$(wc -l < "$CSV_PATH")

SLEEP_DURATION=900  # 15 minutes
HOURLY_SLEEP_INTERVAL=3600  # 1 hour
last_sleep_time=$(date +%s)

echo "CSV file: $CSV_PATH"
echo "Total lines in CSV: $TOTAL_LINES"
echo "Mode: $MODE"

if [[ "$MODE" == "performance" && -n "$FILE_ADDRESS" ]]; then
  echo "Performance mode with specific file address: $FILE_ADDRESS"
  MATCHING_LINE=$(grep "$FILE_ADDRESS" "$CSV_PATH" | head -n 1)
  if [[ -z "$MATCHING_LINE" ]]; then
    echo "Error: File address '$FILE_ADDRESS' not found in CSV file"
    exit 1
  fi
  echo "Found matching line in CSV: $MATCHING_LINE"
fi

while true; do
  echo "================================"
  echo "Downloading file..."
  echo "================================"
  echo "$(date +"%A, %B %d, %Y %H:%M:%S")"
  
  case "$MODE" in
    performance)
      if [[ -n "$FILE_ADDRESS" ]]; then
        file_ref="$FILE_ADDRESS"
        file_hash=$(echo "$MATCHING_LINE" | cut -d ',' -f $FILE_HASH_INDEX | head -n 1)
        file_size=$(echo "$MATCHING_LINE" | cut -d ',' -f $FILE_SIZE_INDEX | head -n 1)
        file_name=$(echo "$MATCHING_LINE" | cut -d ',' -f $FILE_NAME_INDEX | head -n 1)
      else
        # The file selected here is ~4GB in size.
        current_line=$(sed -n '2p' "$CSV_PATH")
        file_ref=$(echo "$current_line" | cut -d ',' -f $FILE_REF_INDEX | head -n 1)
        file_hash=$(echo "$current_line" | cut -d ',' -f $FILE_HASH_INDEX | head -n 1)
        file_size=$(echo "$current_line" | cut -d ',' -f $FILE_SIZE_INDEX | head -n 1)
        file_name=$(echo "$current_line" | cut -d ',' -f $FILE_NAME_INDEX | head -n 1)
      fi
      ;;
    delayed)
      if [[ $current_line_index -gt $TOTAL_LINES ]]; then
        current_line_index=2
        echo "Completed full cycle: sleeping for $((SLEEP_DURATION / 60)) minutes..."
        echo "Returning to the beginning of the 16 files."
        sleep $SLEEP_DURATION
      fi
      
      current_line=$(sed -n "${current_line_index}p" "$CSV_PATH")
      file_ref=$(echo "$current_line" | cut -d ',' -f $FILE_REF_INDEX | head -n 1)
      file_hash=$(echo "$current_line" | cut -d ',' -f $FILE_HASH_INDEX | head -n 1)
      file_size=$(echo "$current_line" | cut -d ',' -f $FILE_SIZE_INDEX | head -n 1)
      file_name=$(echo "$current_line" | cut -d ',' -f $FILE_NAME_INDEX | head -n 1)
      
      echo "Processing line $current_line_index of $TOTAL_LINES"
      current_line_index=$((current_line_index + 1))
      ;;
    random)
      random_line_num=$((2 + RANDOM % (TOTAL_LINES - 1)))
      current_line=$(sed -n "${random_line_num}p" "$CSV_PATH")
      file_ref=$(echo "$current_line" | cut -d ',' -f $FILE_REF_INDEX | head -n 1)
      file_hash=$(echo "$current_line" | cut -d ',' -f $FILE_HASH_INDEX | head -n 1)
      file_size=$(echo "$current_line" | cut -d ',' -f $FILE_SIZE_INDEX | head -n 1)
      file_name=$(echo "$current_line" | cut -d ',' -f $FILE_NAME_INDEX | head -n 1)
      
      echo "Processing random line $random_line_num of $TOTAL_LINES"
      ;;
  esac

  echo "Downloading file: $file_name"
  download_file "$file_ref" "$file_hash" "$file_size"
  
  # Check if it's time for hourly sleep
  if [[ "$MODE" == "performance" || "$MODE" == "random" ]]; then
    current_time=$(date +%s)
    time_since_last_sleep=$((current_time - last_sleep_time))
    
    if [[ $time_since_last_sleep -ge $HOURLY_SLEEP_INTERVAL ]]; then
      echo "Hourly bandwidth break: sleeping for $((SLEEP_DURATION / 60)) minutes..."
      sleep $SLEEP_DURATION
      last_sleep_time=$(date +%s)
    fi
  fi
  
  sleep "$SLEEP_INTERVAL"
done
